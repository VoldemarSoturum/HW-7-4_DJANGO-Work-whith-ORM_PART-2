# Школа — переход с FK на M2M между Student и Teacher

Пошаговый процесс, который мы выполнили: от первоначальной схемы с `ForeignKey` у `Student` к `ManyToManyField`, включая перенос данных, правки шаблона и оптимизацию числа SQL‑запросов.

## Состав проекта (важные файлы)

- `school/models.py` — модели `Teacher` и `Student`.
- `school/views.py` — функция `students_list` с оптимизацией запросов.
- `templates/school/students_list.html` — шаблон с выводом всех учителей ученика.
- `school/migrations/` — миграции, в т.ч. дата‑миграция переноса связей FK → M2M.
- `school.json` — исходные данные (fixtures).

## Требования и запуск окружения

```bash
pip install -r requirements.txt
```

## База: начальные миграции и загрузка данных

> Важно: исходные данные нужно загрузить **до** изменения схемы на M2M (иначе `loaddata` не применится к новой схеме).

```bash
python manage.py makemigrations # создадим первую миграцию
python manage.py migrate        # применяем существующие миграции (например, 0001 и 0002)
python manage.py loaddata school.json # выгружем данные из json
```

---

## Рефакторинг моделей: FK → M2M

Меняем связь у `Student` с одного учителя (`ForeignKey`) на список учителей (`ManyToManyField`).

### Итоговое состояние модели `Student`

```python
# school/models.py
class Student(models.Model):
    name = models.CharField(max_length=30, verbose_name='Имя')
    teachers = models.ManyToManyField('school.Teacher', related_name='students', blank=True)
    group = models.CharField(max_length=10, verbose_name='Класс')
```

---

## Вариант дальнейших действий по **АККУАТНОЙ** миграции (в «3 приёма», некий "пузырьковый" вариант): Add → Copy → Remove

### Шаг 1. Добавляем M2M, FK пока оставляем

Во `Student` временно существуют **оба** поля: старое `teacher` (FK) и новое `teachers` (M2M).

```python
class Student(models.Model):
    name = models.CharField(max_length=30, verbose_name='Имя')
    teacher = models.ForeignKey('school.Teacher', on_delete=models.CASCADE)  # временно оставляем
    teachers = models.ManyToManyField('school.Teacher', related_name='students', blank=True)  # новое поле
    group = models.CharField(max_length=10, verbose_name='Класс')
```

Создаём и применяем миграцию:

```bash
python manage.py makemigrations
python manage.py migrate
```

### Шаг 2. Переносим данные FK → M2M (данные‑миграция)

Создаём пустую миграцию и добавляем перенос:

```bash
python manage.py makemigrations --empty school -n copy_fk_to_m2m
```

В файл "пустой" миграции который был создан добавляем:

```python
from django.db import migrations

def copy_fk_to_m2m(apps, schema_editor):
    Student = apps.get_model('school', 'Student')
    for s in Student.objects.all():
        if getattr(s, 'teacher_id', None):
            s.teachers.add(s.teacher_id)

class Migration(migrations.Migration):
    dependencies = [
        ('school', '0003_student_teachers'),  # подставьте актуальное имя файла предыдущей миграции
    ]
    operations = [
        migrations.RunPython(copy_fk_to_m2m, migrations.RunPython.noop),
    ]
```

Применяем:

```bash
python manage.py migrate
```

### Шаг 3. Удаляем старое поле FK

Убираем поле `teacher` из модели и генерируем миграцию на удаление:

```python
class Student(models.Model):
    name = models.CharField(max_length=30, verbose_name='Имя')
    teachers = models.ManyToManyField('school.Teacher', related_name='students', blank=True)
    group = models.CharField(max_length=10, verbose_name='Класс')
```

```bash
python manage.py makemigrations
python manage.py migrate
```
## Если не получилось выполнить ШАГ 3 или мы затупили. Нужно сделать ещё одну миграцию.
```bash
 python manage.py makemigrations --name remove_teacher_fk school
```
Создасться файл 0006_remove_teacher_fk.py с содержимым:

```python
# Generated by Django 5.2.7 on 2025-10-21 12:05

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('school', '0005_copy_fk_to_m2m'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='student',
            name='teacher',
        ),
    ]
```
После этого опять применяем миграции
```bash
python manage.py migrate

```

> Теперь все прежние связи «ученик → учитель» сохранены в новой M2M‑связи, и каждому ученику можно назначать сколько угодно учителей.

---

## Вариант такой же **АККУРАТНОЙ** миграции (компактно в одной миграции)

Если хочется одной миграцией без трёх файлов, порядок операций **внутри** единственного файла должен быть таким:

```python
operations = [
    migrations.AddField(... teachers ...),                                  # 1) создать M2M‑таблицу
    migrations.RunPython(copy_fk_to_m2m, migrations.RunPython.noop),        # 2) перенести данные из FK
    migrations.RemoveField(model_name='student', name='teacher'),           # 3) удалить FK
]
```

Код переноса такой же, как выше.

---

## Правки шаблона

`templates/school/students_list.html` — выводим всех учителей ученика:

```html
{% for student in object_list %}
  <li>
    {{ student.name }} {{ student.group }}<br>
    Преподаватели:
    {% for teacher in student.teachers.all %}
      {{ teacher.name }}: {{ teacher.subject }}{% if not forloop.last %}, {% endif %}
    {% empty %} — {% endfor %}
  </li>
{% endfor %}
```

## Правки view (оптимизация числа SQL‑запросов)

`school/views.py` — используем `prefetch_related` для M2M, чтобы не делать отдельный запрос на каждого ученика:

```python
ordering = 'group'
students = Student.objects.all().order_by(ordering).prefetch_related('teachers')
context['object_list'] = students
```

> Это закрывает доп. задание по анализу запросов: теперь ORM сделает 1 запрос за студентов и 1 запрос за их учителей, вместо N+1.

---

## Проверка и запуск

```bash
python manage.py migrate
python manage.py runserver
```

Открываем главную страницу. Для входа в админку (если нужно):

```bash
python manage.py createsuperuser
```

---

## Частые проблемы и как их решить

- **«field `teacher` doesn’t exist» в дата‑миграции** — удалили FK слишком рано. Убедитесь, что порядок **AddField → RunPython → RemoveField** соблюдается (либо тремя миграциями по очереди, либо в одной миграции — именно таким порядком в `operations`).  
- **У некоторых студентов нет учителя** — код переноса использует `getattr(s, 'teacher_id', None)`, так что пустые значения пропускаются.  
- **Большие данные** — миграции работают в транзакции по умолчанию. Для особо тяжёлых операций можно использовать `atomic = False` у миграции, но сейчас это не требуется.

---

## Необязательные улучшения

- В админке для удобного выбора учителей у ученика можно добавить:
  ```python
  @admin.register(Student)
  class StudentAdmin(admin.ModelAdmin):
      filter_horizontal = ('teachers',)
  ```
- В шаблоне можно стилизовать список учителей бейджиками.

---

Если потребуется, можно «сплющить» миграции позже через `squashmigrations`, когда функционал устоится.

- Итог на скриншотах 

Вид итоговой страницы
![итоговая страница](https://github.com/VoldemarSoturum/HW-7-4_DJANGO-Work-whith-ORM_PART-2/blob/main/EX1-ORM_Migrations/FOR_README/School-after-migrate.png) 

Вид конечной диаграммы взят из DBeaver
![Диаграмма](https://github.com/VoldemarSoturum/HW-7-4_DJANGO-Work-whith-ORM_PART-2/blob/main/EX1-ORM_Migrations/FOR_README/netology_orm_migrations-public.png)

#!!!ТЕСТЫ!!!

Инструкция по тестам проекта: что именно покрывается, где лежат файлы и как запускать — как целиком, так и по одному тесту.

---

## Что покрывают тесты

### 1) `school/tests/test_models.py`
Проверяет доменную логику моделей:
- **M2M у студента**: у `Student` может быть несколько `Teacher` (`teachers.count()`).
- **`related_name="students"`**: у `Teacher` доступ к ученикам через `teacher.students`.
- **Операции M2M**: добавление/удаление связей `add()` / `remove()`.
- **`__str__`**: человекочитаемые строки для `Teacher` и `Student`.

> Замечание: тест сравнивает состав учеников у учителя без учёта порядка (`assertCountEqual`), чтобы не зависеть от коллаций БД (сортировки кириллицы).

### 2) `school/tests/test_views.py`
Проверяет представление и шаблон списка учеников:
- Страница с именем URL `students` отдаёт **200 OK**.
- В контексте присутствует `object_list`.
- В HTML выводятся **все учителя** для каждого ученика (имена и предметы).

### 3) `school/tests/test_queries.py`
Проверяет производительность (анти-N+1):
- Во вью используется `prefetch_related('teachers')` для связи M2M.
- Количество SQL-запросов на страницу списка — **не больше 3–4** (студенты, черезтабличные связи M2M, учителя). Тест упадёт, если `prefetch_related` убрать.

---

## Где лежат файлы

```
school/
  tests/
    test_models.py
    test_views.py
    test_queries.py
```

---

## Как запускать тесты

### Вариант A. Стандартный раннер Django

#### Запустить все тесты
```bash
python manage.py test -v 2
```

#### По одному файлу
```bash
python manage.py test school.tests.test_models -v 2
python manage.py test school.tests.test_views -v 2
python manage.py test school.tests.test_queries -v 2
```

#### Один класс / один тест
```bash
python manage.py test school.tests.test_models.TestModels -v 2
python manage.py test school.tests.test_models.TestModels.test_related_name_from_teacher -v 2
```

#### Полезные флаги
```bash
python manage.py test --keepdb -v 2     # быстрее повторы: не пересоздаёт БД
python manage.py test --parallel 1 -v 2  # без параллелизма (удобно для детальных логов)
```

### Вариант B. Pytest (опционально)

#### Установка/настройка
```bash
pip install pytest pytest-django
```
Создайте `pytest.ini` в корне проекта:
```ini
[pytest]
DJANGO_SETTINGS_MODULE = website.settings   # замените на ваш модуль настроек
python_files = tests.py test_*.py *_tests.py
```

#### Запуск
```bash
pytest -q                              # все тесты
pytest -q school/tests/test_models.py  # один файл
pytest -q school/tests/test_views.py::TestStudentsListView::test_template_renders_teachers  # один тест
pytest -q --reuse-db                   # держать тестовую БД между прогонами
```

---

## Подготовка окружения (чек-лист)

1. Установить зависимости:
   ```bash
   pip install -r requirements.txt
   ```
2. Убедиться, что БД настроена в `settings.py` (PostgreSQL/MySQL/SQLite).
   - Рекомендация: убрать предупреждение про авто-ID, добавив:
     ```python
     DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
     ```
3. Применить миграции:
   ```bash
   python manage.py migrate
   ```
4. (Опционально) Наполнить базу фикстурами до смены схемы:
   ```bash
   python manage.py loaddata school.json
   ```
5. Для локального просмотра:
   ```bash
   python manage.py runserver
   ```

---

## Типичные проблемы и решения

- **IntegrityError / `teacher_id NOT NULL` при создании Student**: значит, не удалён старый FK. Нужна миграция:
  ```python
  migrations.RemoveField(model_name='student', name='teacher')
  ```
  Прогон миграций создаст таблицу без колонки `teacher_id`.

- **Провал теста на количество запросов**: проверь, что во `view` есть
  ```python
  Student.objects.all().order_by('group').prefetch_related('teachers')
  ```

- **Разный порядок строк с кириллицей**: тесты не должны зависеть от сортировки БД;
  вместо сравнения списков «как есть» используйте `assertCountEqual` или сортируйте обе стороны в Python.

---

## Пример команд «по шагам»

```bash
# Модели
python manage.py test school.tests.test_models -v 2

# Вью + шаблон
python manage.py test school.tests.test_views -v 2

# Производительность (N+1)
python manage.py test school.tests.test_queries -v 2
```

